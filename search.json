[{"title":"LEANN","url":"/2025/10/31/LEANN/","content":"论文笔记\n论文提出了一种针对资源受限的个人设备的低存储的ANN搜索索引\n研究背景\n目前基于嵌入的搜索（向量检索技术）已经被广泛应用在推荐系统和RAG中，个人设备对此也逐渐突显需求。但由于个人设备存储空间限制和ANN索引存储开销过大的原因，无法在个人设备中存储必要的索引结构。因此，减少索引存储开销和保持搜索质量和延迟成为了关键问题。\n行业需求\n随着智能手机等边缘设备越来越普及，这些设备不断生成多模态数据（如图像、文字、音频等）。这些数据如果能被有效地检索、组合起来，对用户回忆、检索过去信息、辅助智能应用等都有潜在价值。\n边缘设备上向量检索的应用：设备端RAG系统、个性化推荐系统、图像与视频内容检索等。\n研究动机\n动态重算嵌入以节省存储：传统图索引（如 HNSW）在查询时只会访问少量向量，因此LEANN不再将所有嵌入存储在磁盘上，而是在查询时按需重算。为减少延迟，LEANN 采用了双层遍历算法（结合近似与精确队列）和动态批处理机制（提高 GPU 利用率），从而显著降低重算开销。\n图结构剪枝以压缩索引元数据：即使不存储嵌入，图索引的邻接信息仍带来较大存储负担。LEANN 通过分析发现，许多边和节点对检索效果贡献有限，因此提出了高出度保持的剪枝策略，去除冗余边、保留关键枢纽节点，从而在几乎不影响搜索精度的前提下，大幅减少索引体积。\n为此，本论文提出了LEANN，通过结合紧凑图索引和高效即时重计算，以实现最小的存储负担和快速准确的检索。\n具体技术\n在HNSW查询中，只有很少的节点会被访问，因此 LEANN 不再预先存储全部向量，而是对这些少量节点在查询时即时重算，从而大幅降低存储成本，同时保持搜索准确率和延迟在可接受范围内。\n\n重计算虽然能节省存储空间，但仍然会导致较高的延迟。\n并且剩余的图元数据可能仍然占比很大的存储开销。\n\n对此，LEANN 采用两级图遍历算法和动态批处理机制来降低重新计算的延迟。并使用一种高度保留的图剪枝技术，以显著减少图元数据所需的存储空间。\n系统工作流程\n对于给定的数据集，LEANN首先计算所有条目的嵌入向量，并利用现有的图索引方法构建向量索引。然后LEANN丢弃所有条目的嵌入向量，并通过一种高度保留的图剪枝算法对图结构进行剪枝，以减少存储开销。该算法优先保留访问频繁的“枢纽节点”因为节点访问分布往往极度偏斜。\n在查询时，LEANN使用一个两级搜索算法在被剪枝后的图上进行遍历，识别并优先探索那些更有潜力的节点。这些被选中的节点随后会被发送到嵌入服务器（一个设备端组件，用于调用原始嵌入模型重新计算节点的嵌入）以获取对应的向量表示。\n为了进一步提高 GPU 利用率并减少延迟，LEANN 采用了一种动态批处理策略，用来调度在 GPU 上的嵌入计算任务。此外，当设备上有额外磁盘空间可用时，LEANN 会将这些“枢纽节点（hub nodes）”缓存在磁盘中。运行时，系统仅对未缓存的节点重新计算嵌入，而对已缓存的节点则直接从磁盘加载，从而减少计算负担并进一步提升查询性能。\nTwo-Level Search (向量搜索过程)\n主要思想：\n只需对近似距离排名靠前的向量进行重新排序（re-ranking），就足以获得较高的召回率，同时能有效剪枝掉在错误方向上的节点。\nAQ（Approximate Queue，近似队列），用于存储所有计算近似距离的已访问节点；EQ（Exact Queue, 精确队列），用于存放计算精确距离的节点；re-ranking ratio（重新排序比例），用于控制进行精确计算节点的比例。\n算法流程\n从入口节点开始，计算其精确距离，将入口节点加入EQ、R和visited。如果EQ不为空，每次从EQ中取出距离查询向量q最近的节点v，从R中取出距离q最远的节点f。若dvq&gt;dfq则结束算法，否则遍历v的所有邻居，对每个未访问的节点n，将其加入visited，计算近似距离d_ap，然后将节点n加入到AQ（队列中的节点会保存节点标识和对应距离，d_ap的计算可以通过PQ实现）。然后从AQ中取出前a%的节点（最有潜力的节点），对这些节点计算精确距离d_ex，将其加入ED和R。\nDynamic batching strategy （搜索过程）\n图索引每次扩展都要根据上次扩展结果选出最有希望的节点，会导致每次GPU只能处理很小一批数据，使得GPU资源浪费严重、吞吐低、延迟高。动态批处理策略放宽这种严格的数据依赖性，每次扩展从候选队列中一次取出多个节点进行扩展，将它们的邻居节点使用GPU一起进行重计算。这样计算更高效、延迟降低，扩展顺序虽然有延迟，但整体搜索结果几乎没有影响。\n\n每个节点平均有 8 个邻居；\n原始做法：每次扩展 1 个节点 → batch size &#x3D; 8；\n动态批处理：一次从队列取 8 个节点 → 共 8×8 &#x3D; 64 个邻居 → batch size &#x3D; 64。\n\nHigh Degree Preserving Graph Pruning （索引构建阶段）\nLEANN引入了一个用户定义的磁盘预算C。如果图元数据超过这个阈值，LEANN会触发剪枝算法。\n主要思想：\n只要保持高度数的枢纽节点，即可维持搜索性能，在减少边数量的同时保持检索准确率。\nG：原始图；V：节点集合；ef：候选集合大小；M：高度数节点允许的最大连接数；m：普通节点允许的最大连接数(m&lt;M)；a：高节点度数比例\n\n计算G中每个节点v的度数Dv，并初始化G1用来存放剪枝后的图。\n从D中选出出度最高的前a%节点，记为集合V*\n对V中每个节点v进行计算\n\n调用Best-First Search算法得到v的候选邻居列表W，如果v属于V*，M0&#x3D;M，否则，M0&#x3D;m。\n通过原始启发式（d(p, p′)≤d(p, p′)这种启发式剪枝）从W中选取M0个节点作为v的邻居并建立双向边，并添加到G1。\n如果存在邻居的出边度数大于M，则进行剪枝出度边。\n\nLEANN 使用 按需访问和动态批处理（dynamic batching）：\n查询开始时，只将部分必要的图元数据加载到内存（例如初始候选节点及其邻居信息）。\n随着搜索的推进，按需加载更多节点信息，同时对节点向量进行重算（embedding recomputation）。\n\n\n这种策略可以避免一次性占用大量内存，同时保证图遍历的效率。\n\nLEANN 并不是把整个索引图一次性载入内存，而是按需加载图的部分结构并结合向量重算，以在低内存环境下实现高效查询。\n","categories":["向量检索"],"tags":["边缘设备","向量检索"]},{"title":"Hello World","url":"/2025/10/30/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["hexo教程"],"tags":["hexo教程"]}]